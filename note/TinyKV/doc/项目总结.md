# Project1

Project1 要求构建一个支持列族（CF）的独立键值存储 gRPC 服务。

> 列族（Column Family）是将多个列作为一个整体进行管理的单位。它由一个键值对组成，其中键映射到一组列。与关系型数据库中的表类似，每个键值对相当于一行。每个列族中的列具有相同的前缀，这有助于提高数据读取和写入的效率。在多列存储（比如 MYSQL）中很显然，一列就是一个 CF。但是 KV 是单列存储的，因为为了实现 CF，必须通过单列来模拟多列，方法很简单，就是在 Key 前面拼上 CF 前缀。

<font color=red>**// TODO：多列，单列实现 CF 示例图**</font>

在 Tinykv 中，涉及的 CF 有三种，分别是 Default、Lock 和 Write。它们用于支持 Project4 中的事务模型。在 Project1 中，我们暂时不需要去深入理解。在 Project1 中，和 CF 有关的方法已经在 engine_util 包下为我们提供好了， 我们直接拿来使用即可。

根据参考文档，Project1 要求我们实现的内容可以概括为以下两个部分：

1. 实现对底层 badger api 的包装，主要涉及修改的代码文件是 standalone_storage.go, 需要实现 Storage 接口的 **Write** 和 **Reader** 方法，来实现对底层 badger 数据库的读写。
2. 实现 **RawGet**，**RawScan**，**RawPut**，**RawDelete** 四个方法，主要涉及修改的代码文件是 raw_api.go

<font color=red>**// TODO：什么是 Badger**</font>

## 实现独立存储引擎 StandAloneStorage

在 `standalone_storage.go`中，查看需要我们实现的部分，如下：

```go
type StandAloneStorage struct { 
    // Your Data Here (1).
}
func NewStandAloneStorage(conf *config.Config) *StandAloneStorage {
	// Your Code Here (1).
}
func (s *StandAloneStorage) Start() error {
	// Your Code Here (1).
}
func (s *StandAloneStorage) Stop() error {
	// Your Code Here (1).
}
func (s *StandAloneStorage) Reader(ctx *kvrpcpb.Context) (storage.StorageReader, error) {
	// Your Code Here (1).
}
func (s *StandAloneStorage) Write(ctx *kvrpcpb.Context, batch []storage.Modify) error {
	// Your Code Here (1).
}
```

我们查看`storage.go`：

```go
// Storage represents the internal-facing server part of TinyKV, it handles sending and receiving from other
// TinyKV nodes. As part of that responsibility, it also reads and writes data to disk (or semi-permanent memory).
type Storage interface {
	Start() error
	Stop() error
	Write(ctx *kvrpcpb.Context, batch []Modify) error
	Reader(ctx *kvrpcpb.Context) (StorageReader, error)
}
```

显而易见，我们需要实现的独立存储引擎`StandAloneStorage`就是要实现`Storage`接口。提示中说明，我们需要实现的独立存储引擎只是 badger 键值 API 的包装器。那么，我们的`StandAloneStorage`就是对`Badger`数据库的一层包装：

```go
type StandAloneStorage struct {
    db *badger.DB
}
```

`db`字段将用于与Badger数据库进行交互，执行各种存储操作。

接下来考虑实现 `Reader` 方法。该方法要求返回一个`StorageReader`，`StorageReader`是一个在 `storage.go`中定义的接口：

```go
type StorageReader interface {
	// When the key doesn't exist, return nil for the value
	GetCF(cf string, key []byte) ([]byte, error)
	IterCF(cf string) engine_util.DBIterator
	Close()
}
```

根据参考文档提示，我们应该使用 badger.Txn 来实现 Reader 函数，所以我们需要声明一个 badgerReader 结构体来实现 StorageReader 接口，badgerReader 结构体内部包含对 badger.Txn 的引用。要实现 StorageReader 接口，就要实现其所有方法。根据提示，`engine_util` 包中已经实现了相关操作，我们直接调用就行了，比较简单，这里不再赘述。对于`Close`方法，其确保在使用完`BadgerReader`后，正确地关闭事务并释放资源。根据`Badger`的官方文档，使用其`Discard`函数丢弃事务即可。

至此，我们已经实现了 StorageReader 接口，接下来，通过创建一个新的只读事务，并返回一个`BadgerReader`实例，我们就实现了 Reader 方法：

```go
func (s *StandAloneStorage) Reader(ctx *kvrpcpb.Context) (storage.StorageReader, error) {
	txn := s.db.NewTransaction(false)
	return &BadgerReader{txn}, nil
}
```

接下来考虑实现 `Write` 方法。该方法传入了一个包含多个`Modify`对象的切片`batch`。在`modify.go`中，可以找到对`Modify`的定义。可以发现，Modify 对象代表着 Put 和 Delete 两种操作。这两种操作在`engine_util`已经实现好了。所以，我们只需要对每一个操作，从`engine_util`中调用相应的已经实现好的函数即可。

## 实现原始键值服务处理程序

本部分要求使用实现的存储引擎构建原始键值服务处理程序，就是对存储引擎的再一次封装。具体地，我们需要在`raw_api.go`中，实现`RawGet`，`RawScan`，`RawPut`，`RawDelete`四个方法。

对于`RawGet`方法，该方法传入一个`*kvrpcpb.RawGetRequest`类型的参数，代表`RawGet`请求。函数需要返回一个`*kvrpcpb.RawGetResponse` 类型的响应。在`kvrpcpb.pb.go`中可以查看这两种类型的定义。我们需要的字段就是 `RawGetRequest`中的`Key`和`Cf`。并根据`Key`和`Cf`,使用`reader`的`GetCF`方法获取相应`value` 值，然后创建一个`RawGetResponse`响应对象，包含获取到的值`value`和一个布尔值`NotFound`，表示是否找到了该键。最后返回`RawGetResponse`响应对象即可。对于`RawPut`，`RawDelete`，`RawScan`方法也是同理，在`kvrpcpb.pb.go`中查看相应类型的定义，使用相应方法获取指定的值，根据相应的值创建相应的响应对象返回即可。

需要注意`*kvrpcpb.RawScanRequest`类型中有`Limit`字段，其限制了一次扫描操作的最大键值对数量，这对于避免一次性读取过多数据、控制内存使用和提高性能非常有用。所以在实现`RawScan`方法时要注意维护当前扫描的数量。

# Project2

在这个项目中，我们将基于 Raft 实现一个高可用的键值服务器，这不仅需要实现 Raft 算法，还需要实际使用它，并带来更多挑战，如使用 Badger 管理 Raft 的持久化状态、为快照消息添加流量控制等。

该项目包括三个部分：

1. 实现基本的 Raft 算法（Project2A）
2. 在 Raft 上构建一个容错的键值服务器（Project2B）
3. 增加 Raft 日志 GC 和快照支持（Project2C）

## Project2A

Project2A 要求我们实现基本的 Raft 算法，并提供接口给上层使用。